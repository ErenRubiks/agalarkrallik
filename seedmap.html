<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<title>Professional Seed Map</title>
<style>
  body {
    margin: 0;
    background: #0e0e0e;
    color: #fff;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    background: #181818;
    padding: 10px;
    border-radius: 8px;
    z-index: 10;
  }
  input, button {
    background: #222;
    color: #fff;
    border: 1px solid #333;
    padding: 5px;
    border-radius: 4px;
  }
  canvas { display: block; }
</style>
</head>
<body>

<div id="ui">
  Seed:
  <input id="seed" value="6331667460812775853">
  <button id="btn">Generate</button>
</div>

<canvas id="map"></canvas>

<script>
const canvas = document.getElementById("map");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// ================= RANDOM =================
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}

// ================= PERLIN =================
function Perlin(seed) {
  const rand = mulberry32(seed);
  const p = new Uint8Array(512);
  for (let i = 0; i < 256; i++) p[i] = i;
  for (let i = 255; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [p[i], p[j]] = [p[j], p[i]];
  }
  for (let i = 0; i < 256; i++) p[i + 256] = p[i];

  return function(x, y) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    x -= Math.floor(x);
    y -= Math.floor(y);

    const u = x*x*x*(x*(x*6-15)+10);
    const v = y*y*y*(y*(y*6-15)+10);

    const a = p[X] + Y;
    const aa = p[a], ab = p[a + 1];
    const b = p[X + 1] + Y;
    const ba = p[b], bb = p[b + 1];

    const grad = (h, x, y) =>
      ((h & 1) ? -x : x) + ((h & 2) ? -y : y);

    return lerp(
      lerp(grad(aa, x, y), grad(ba, x - 1, y), u),
      lerp(grad(ab, x, y - 1), grad(bb, x - 1, y - 1), u),
      v
    );
  }
}

const lerp = (a,b,t)=>a+(b-a)*t;

// ================= BIOME =================
function biome(h, heat, wet) {
  if (h < -0.2) return "#0b3d91";
  if (h < 0) return "#1e90ff";
  if (h < 0.05) return "#f4e19c";
  if (heat > 0.4 && wet < 0) return "#e5c07b";
  if (heat < -0.3) return "#ffffff";
  if (wet > 0.3) return "#2ecc71";
  if (h > 0.6) return "#7f8c8d";
  return "#27ae60";
}

// ================= MAP =================
function generate() {
  const seedStr = document.getElementById("seed").value;
  let seed = 0;
  for (let c of seedStr) seed += c.charCodeAt(0);

  const hN = Perlin(seed);
  const tN = Perlin(seed + 999);
  const mN = Perlin(seed + 7777);

  const img = ctx.createImageData(canvas.width, canvas.height);
  let i = 0;
  const zoom = 200;

  for (let y = 0; y < canvas.height; y++) {
    for (let x = 0; x < canvas.width; x++) {
      const nx = x / zoom;
      const ny = y / zoom;

      let h = 0, f = 1, a = 1;
      for (let o = 0; o < 4; o++) {
        h += hN(nx*f, ny*f) * a;
        f *= 2;
        a *= 0.5;
      }

      const col = biome(h, tN(nx,ny), mN(nx,ny));
      const rgb = col.match(/\w\w/g).map(v=>parseInt(v,16));

      img.data[i++] = rgb[0];
      img.data[i++] = rgb[1];
      img.data[i++] = rgb[2];
      img.data[i++] = 255;
    }
  }
  ctx.putImageData(img,0,0);
}

// BUTTON
document.getElementById("btn").onclick = generate;

// FIRST DRAW
generate();
</script>
</body>
</html>
